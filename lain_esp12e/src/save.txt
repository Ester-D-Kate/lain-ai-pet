/*
 * ========================================
 *   ESP12E CAR BOT CONTROLLER - FINAL
 *   WITH GYRO ANGLE-BASED TURNING
 * ========================================
 */

// ==================== LIBRARIES ====================
#include <ESP8266WiFi.h>
#include <PubSubClient.h>
#include <ESP8266WebServer.h>
#include <EEPROM.h>
#include <ArduinoJson.h>
#include <Wire.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Servo.h>

// ==================== HARDWARE PIN DEFINITIONS ====================
const int ENA_PIN = 2;
const int ENB_PIN = 1;
const int IN1_PIN = 14;
const int IN2_PIN = 12;
const int IN3_PIN = 13;
const int IN4_PIN = 16;
const int SERVO_PIN = 15;

// ==================== GLOBAL VARIABLES ====================
String ssid_stored = "";
String password_stored = "";
String control_password_stored = "1234";
bool configMode = false;
int wifiConnectionAttempts = 0;
const int MAX_WIFI_ATTEMPTS = 5;

const char* mqtt_server = "broker.emqx.io";
const int mqtt_port = 1883;
const char* mqtt_user = "";
const char* mqtt_password = "";
const char* command_topic = "carbot/command";
const char* status_topic = "carbot/status";

const int EEPROM_MAGIC = 0xAB12;

WiFiClient espClient;
PubSubClient mqttClient(espClient);
ESP8266WebServer server(80);
Adafruit_MPU6050 mpu;
Servo servoMotor;

String currentDirection = "S";
int currentSpeed = 0;
int servoAngle = 90;

// ==================== GYRO ANGLE TRACKING ====================
// TWO ANGLE SYSTEMS:
float angleZ_reset = 0.0;      // Resets for F/B - straight line PID
float angleZ_absolute = 0.0;   // NEVER resets - for turning
float gyroZOffset = 0.0;
const float GYRO_DEAD_ZONE = 0.02;
int stationaryCount = 0;
unsigned long lastDriftCorrection = 0;
bool gyroInitialized = false;

// ==================== PID VARIABLES ====================
float Kp = 5.0;
float Ki = 0.0;
float Kd = 0.0;
float desired_angle_reset = 0.0;      // For F/B straight line
float desired_angle_absolute = 0.0;   // For turning commands
float integral = 0.0;
float previous_error = 0.0;
unsigned long prevTime = 0;

// ==================== MOVEMENT STATE ====================
bool isMovingForward = false;
bool isMovingBackward = false;
bool isTurning = false;            // NEW: Angle-based turning active
int targetTurnAngle = 0;           // NEW: Target angle for turning

unsigned long lastStatusTime = 0;
bool serialEnabled = true;

// ==================== FUNCTION DECLARATIONS ====================
void clearEEPROM();
void loadCredentials();
void saveCredentials(String ssid, String password);
void saveControlPassword(String password);
bool validateControlPassword(String password);
bool connectToWiFi();
void startConfigMode();
void handleRoot();
void handleScan();
void handleConnect();
void handleSetPassword();
void setupWebServer();
void setupMQTT();
void reconnectMQTT();
void mqttCallback(char* topic, byte* payload, unsigned int length);
void publishStatus();
void initGyro();
void calibrateGyro();
void updateGyro();
void resetPID();
float computePID(float setpoint, float current_value, float dt);
void controlMotors(String direction, int speed, float pidCorrection);
void stopMotors();
void updateServo(int angle);
void disableSerial();
int normalizeAngle(int angle);
int getShortestPath(int current, int target);

// ==================== SERIAL HELPER ====================
void disableSerial() {
  if (serialEnabled) {
    Serial.flush();
    delay(100);
    Serial.end();
    serialEnabled = false;
  }
}

// ==================== ANGLE UTILITIES ====================
// Normalize angle to -180 to +179 range
int normalizeAngle(int angle) {
  while (angle > 179) angle -= 360;
  while (angle < -180) angle += 360;
  return angle;
}

// Calculate shortest path between two angles
int getShortestPath(int current, int target) {
  int diff = target - current;
  diff = normalizeAngle(diff);
  return diff;
}

// ==================== EEPROM FUNCTIONS ====================
void clearEEPROM() {
  if (serialEnabled) Serial.println("Clearing EEPROM...");
  for (int i = 0; i < 512; i++) {
    EEPROM.write(i, 0);
  }
  EEPROM.commit();
  if (serialEnabled) Serial.println("‚úì EEPROM cleared");
}

void loadCredentials() {
  if (serialEnabled) Serial.println("Loading credentials from EEPROM...");
  int magic = (EEPROM.read(200) << 8) | EEPROM.read(201);
  if (magic != EEPROM_MAGIC) {
    if (serialEnabled) Serial.println("No valid credentials found");
    return;
  }
  
  int ssidLength = EEPROM.read(0);
  if (ssidLength > 0 && ssidLength < 100) {
    ssid_stored = "";
    for (int i = 0; i < ssidLength; i++) {
      ssid_stored += char(EEPROM.read(1 + i));
    }
  }
  
  int passwordLength = EEPROM.read(100);
  if (passwordLength > 0 && passwordLength < 100) {
    password_stored = "";
    for (int i = 0; i < passwordLength; i++) {
      password_stored += char(EEPROM.read(101 + i));
    }
  }
  
  int controlPasswordLength = EEPROM.read(300);
  if (controlPasswordLength > 0 && controlPasswordLength < 50) {
    control_password_stored = "";
    for (int i = 0; i < controlPasswordLength; i++) {
      control_password_stored += char(EEPROM.read(301 + i));
    }
  }
  
  if (serialEnabled) {
    Serial.println("‚úì Credentials loaded");
    if (ssid_stored.length() > 0) {
      Serial.println("  SSID: " + ssid_stored);
    }
  }
}

void saveCredentials(String ssid, String password) {
  if (serialEnabled) Serial.println("Saving WiFi credentials to EEPROM...");
  for (int i = 0; i < 200; i++) {
    EEPROM.write(i, 0);
  }
  
  EEPROM.write(0, ssid.length());
  for (unsigned int i = 0; i < ssid.length(); i++) {
    EEPROM.write(1 + i, ssid[i]);
  }
  
  EEPROM.write(100, password.length());
  for (unsigned int i = 0; i < password.length(); i++) {
    EEPROM.write(101 + i, password[i]);
  }
  
  EEPROM.write(200, (EEPROM_MAGIC >> 8) & 0xFF);
  EEPROM.write(201, EEPROM_MAGIC & 0xFF);
  EEPROM.commit();
  
  ssid_stored = ssid;
  password_stored = password;
  if (serialEnabled) Serial.println("‚úì WiFi credentials saved");
}

void saveControlPassword(String password) {
  if (serialEnabled) Serial.println("Saving control password to EEPROM...");
  EEPROM.write(300, password.length());
  for (unsigned int i = 0; i < password.length(); i++) {
    EEPROM.write(301 + i, password[i]);
  }
  EEPROM.commit();
  control_password_stored = password;
  if (serialEnabled) Serial.println("‚úì Control password saved");
}

bool validateControlPassword(String password) {
  return (password == control_password_stored);
}

// ==================== WIFI FUNCTIONS ====================
bool connectToWiFi() {
  if (ssid_stored.length() == 0) {
    if (serialEnabled) Serial.println("No stored WiFi credentials");
    return false;
  }
  
  if (serialEnabled) {
    Serial.println("\n--- WiFi Connection Attempt ---");
    Serial.println("SSID: " + ssid_stored);
    Serial.println("Attempt: " + String(wifiConnectionAttempts + 1) + "/" + String(MAX_WIFI_ATTEMPTS));
  }
  
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid_stored.c_str(), password_stored.c_str());
  
  int timeout = 0;
  while (WiFi.status() != WL_CONNECTED && timeout < 20) {
    delay(500);
    if (serialEnabled) Serial.print(".");
    timeout++;
  }
  if (serialEnabled) Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    if (serialEnabled) {
      Serial.println("‚úì WiFi Connected!");
      Serial.print("  IP Address: ");
      Serial.println(WiFi.localIP());
      Serial.print("  Signal: ");
      Serial.print(WiFi.RSSI());
      Serial.println(" dBm");
    }
    wifiConnectionAttempts = 0;
    configMode = false;
    return true;
  } else {
    if (serialEnabled) Serial.println("‚úó Connection failed");
    wifiConnectionAttempts++;
    return false;
  }
}

void startConfigMode() {
  if (serialEnabled) {
    Serial.println("\n========================================");
    Serial.println("  STARTING AP CONFIGURATION MODE");
    Serial.println("========================================");
  }
  configMode = true;
  WiFi.mode(WIFI_AP);
  WiFi.softAP("CarBot_Config", "12345678");
  IPAddress IP = WiFi.softAPIP();
  if (serialEnabled) {
    Serial.println("AP SSID: CarBot_Config");
    Serial.println("AP Password: 12345678");
    Serial.print("Configuration URL: http://");
    Serial.println(IP);
    Serial.println("========================================\n");
  }
}

// ==================== WEB SERVER FUNCTIONS ====================
void handleRoot() {
  String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  <title>CarBot WiFi Setup</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    .container {
      background: white;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 500px;
      width: 100%;
    }
    h1 {
      color: #667eea;
      text-align: center;
      margin-bottom: 10px;
      font-size: 28px;
    }
    h2 {
      color: #666;
      font-size: 18px;
      margin-top: 30px;
      margin-bottom: 15px;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }
    .form-group {
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 8px;
      color: #333;
      font-weight: 600;
    }
    input, select {
      width: 100%;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
    }
    button {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      margin-top: 10px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
    .btn-secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    .status {
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      background: #f0f0f0;
      display: none;
    }
    .status.show { display: block; }
    .status.success { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }
    .checkbox-group {
      display: flex;
      align-items: center;
      margin-top: 10px;
    }
    .checkbox-group input[type="checkbox"] {
      width: auto;
      margin-right: 8px;
    }
    .info-box {
      background: #e7f3ff;
      border-left: 4px solid #2196F3;
      padding: 12px;
      margin-bottom: 20px;
      border-radius: 4px;
      font-size: 14px;
      color: #1976D2;
    }
  </style>
</head>
<body>
  <div class='container'>
    <h1>üöó CarBot Setup</h1>
    <div class='info-box'>
      üì° Configure WiFi and MQTT password. Gyro-enabled angle-based turning!
    </div>
    <h2>üì∂ WiFi Configuration</h2>
    <div class='form-group'>
      <button onclick='scanNetworks()'>Scan for Networks</button>
    </div>
    <div class='form-group'>
      <label for='ssid'>WiFi Network:</label>
      <select id='ssid'>
        <option value=''>Select a network...</option>
      </select>
    </div>
    <div class='form-group'>
      <label for='password'>WiFi Password:</label>
      <input type='password' id='password' placeholder='Enter WiFi password'>
      <div class='checkbox-group'>
        <input type='checkbox' id='showPass' onclick='togglePassword("password", "showPass")'>
        <label for='showPass' style='margin:0; font-weight:normal;'>Show password</label>
      </div>
    </div>
    <div class='form-group'>
      <button onclick='connectWiFi()'>Save & Connect</button>
    </div>
    <h2>üîê MQTT Control Password</h2>
    <div class='form-group'>
      <label for='controlPassword'>Control Password:</label>
      <input type='password' id='controlPassword' placeholder='Min 4 characters' value='1234'>
      <div class='checkbox-group'>
        <input type='checkbox' id='showControl' onclick='togglePassword("controlPassword", "showControl")'>
        <label for='showControl' style='margin:0; font-weight:normal;'>Show password</label>
      </div>
    </div>
    <div class='form-group'>
      <button class='btn-secondary' onclick='setControlPassword()'>Update Password</button>
    </div>
    <div id='status' class='status'></div>
  </div>
  <script>
    function togglePassword(inputId, checkboxId) {
      const input = document.getElementById(inputId);
      const checkbox = document.getElementById(checkboxId);
      input.type = checkbox.checked ? 'text' : 'password';
    }
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status show ' + type;
      setTimeout(() => {
        status.classList.remove('show');
      }, 5000);
    }
    function scanNetworks() {
      showStatus('Scanning...', '');
      fetch('/scan')
        .then(response => response.json())
        .then(data => {
          const select = document.getElementById('ssid');
          select.innerHTML = '<option value="">Select a network...</option>';
          data.networks.forEach(network => {
            const option = document.createElement('option');
            option.value = network.ssid;
            option.textContent = network.ssid + ' (' + network.rssi + ' dBm)';
            select.appendChild(option);
          });
          showStatus('Found ' + data.networks.length + ' networks', 'success');
        })
        .catch(error => {
          showStatus('Scan failed', 'error');
        });
    }
    function connectWiFi() {
      const ssid = document.getElementById('ssid').value;
      const password = document.getElementById('password').value;
      if (!ssid) {
        showStatus('Please select a network', 'error');
        return;
      }
      showStatus('Saving and connecting...', '');
      fetch('/connect', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'ssid=' + encodeURIComponent(ssid) + '&password=' + encodeURIComponent(password)
      })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            showStatus('Saved! Restarting...', 'success');
            setTimeout(() => {
              window.location.reload();
            }, 3000);
          } else {
            showStatus('Failed: ' + data.message, 'error');
          }
        })
        .catch(error => {
          showStatus('Error occurred', 'error');
        });
    }
    function setControlPassword() {
      const password = document.getElementById('controlPassword').value;
      if (password.length < 4) {
        showStatus('Password must be at least 4 characters', 'error');
        return;
      }
      showStatus('Updating...', '');
      fetch('/setpassword', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'password=' + encodeURIComponent(password)
      })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            showStatus('Password updated!', 'success');
          } else {
            showStatus('Update failed', 'error');
          }
        })
        .catch(error => {
          showStatus('Error occurred', 'error');
        });
    }
  </script>
</body>
</html>
)rawliteral";
  server.send(200, "text/html", html);
}

void handleScan() {
  int n = WiFi.scanNetworks();
  String json = "{\"networks\":[";
  for (int i = 0; i < n; i++) {
    if (i > 0) json += ",";
    json += "{\"ssid\":\"" + WiFi.SSID(i) + "\",\"rssi\":" + String(WiFi.RSSI(i)) + "}";
  }
  json += "]}";
  server.send(200, "application/json", json);
}

void handleConnect() {
  if (server.hasArg("ssid") && server.hasArg("password")) {
    String ssid = server.arg("ssid");
    String password = server.arg("password");
    saveCredentials(ssid, password);
    server.send(200, "application/json", "{\"success\":true,\"message\":\"Saved\"}");
    delay(1000);
    ESP.restart();
  } else {
    server.send(400, "application/json", "{\"success\":false,\"message\":\"Missing parameters\"}");
  }
}

void handleSetPassword() {
  if (server.hasArg("password")) {
    String password = server.arg("password");
    if (password.length() >= 4) {
      saveControlPassword(password);
      server.send(200, "application/json", "{\"success\":true}");
    } else {
      server.send(400, "application/json", "{\"success\":false,\"message\":\"Too short\"}");
    }
  } else {
    server.send(400, "application/json", "{\"success\":false,\"message\":\"Missing\"}");
  }
}

void setupWebServer() {
  server.on("/", handleRoot);
  server.on("/scan", handleScan);
  server.on("/connect", HTTP_POST, handleConnect);
  server.on("/setpassword", HTTP_POST, handleSetPassword);
  server.begin();
}
// ==================== MQTT FUNCTIONS ====================
void setupMQTT() {
  mqttClient.setServer(mqtt_server, mqtt_port);
  mqttClient.setCallback(mqttCallback);
}

void reconnectMQTT() {
  if (configMode) return;
  int attempts = 0;
  while (!mqttClient.connected() && attempts < 3) {
    String clientId = "ESP12E_CarBot_" + String(random(0xffff), HEX);
    if (mqttClient.connect(clientId.c_str(), mqtt_user, mqtt_password)) {
      mqttClient.subscribe(command_topic);
      mqttClient.publish(status_topic, "{\"status\":\"online\"}");
    } else {
      attempts++;
      delay(2000);
    }
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  JsonDocument doc;
  DeserializationError error = deserializeJson(doc, payload, length);
  if (error) return;
  
  String receivedPassword = doc["password"] | "";
  if (!validateControlPassword(receivedPassword)) return;
  
  String cmd = doc["cmd"] | "";
  
  // ==================== ANGLE-BASED TURNING ====================
  if (cmd == "R" || cmd == "L") {
    // Check if angle is provided
    if (doc["angle"].is<int>()) {
      int turnAngle = doc["angle"];
      if (doc["speed"].is<int>()) {
        currentSpeed = doc["speed"];
        currentSpeed = constrain(currentSpeed, 0, 100);
      }
      
      // Calculate target angle based on current absolute position
      int currentAbsAngle = normalizeAngle((int)angleZ_absolute);
      
      if (cmd == "R") {
        // Turn right (clockwise) - ADD angle
        targetTurnAngle = normalizeAngle(currentAbsAngle + turnAngle);
      } else {
        // Turn left (counter-clockwise) - SUBTRACT angle
        targetTurnAngle = normalizeAngle(currentAbsAngle - turnAngle);
      }
      
      desired_angle_absolute = targetTurnAngle;
      isTurning = true;
      isMovingForward = false;
      isMovingBackward = false;
      resetPID();
      
      return;
    }
  }
  
  // ==================== STANDARD MOVEMENT COMMANDS ====================
  if (cmd == "F" || cmd == "B" || cmd == "L" || cmd == "R" || cmd == "S") {
    currentDirection = cmd;
    if (doc["speed"].is<int>()) {
      currentSpeed = doc["speed"];
      currentSpeed = constrain(currentSpeed, 0, 100);
    }
    
    if (cmd == "F") {
      isMovingForward = true;
      isMovingBackward = false;
      isTurning = false;
      // Reset the reset angle for straight line PID
      angleZ_reset = 0;
      desired_angle_reset = 0;
      resetPID();
      
    } else if (cmd == "B") {
      isMovingForward = false;
      isMovingBackward = true;
      isTurning = false;
      // Reset the reset angle for straight line PID
      angleZ_reset = 0;
      desired_angle_reset = 0;
      resetPID();
      
    } else if (cmd == "S") {
      stopMotors();
      
    } else if (cmd == "L" || cmd == "R") {
      // Manual turning without angle (old behavior)
      isMovingForward = false;
      isMovingBackward = false;
      isTurning = false;
      controlMotors(currentDirection, currentSpeed, 0);
    }
  }
  
  // ==================== SERVO CONTROL ====================
  if (doc["servo"].is<int>()) {
    int angle = doc["servo"];
    updateServo(angle);
  }
}

void publishStatus() {
  if (!mqttClient.connected() || configMode) return;
  
  JsonDocument doc;
  doc["device_id"] = "esp12e_carbot";
  doc["status"] = "online";
  doc["direction"] = currentDirection;
  doc["speed"] = currentSpeed;
  doc["servo_angle"] = servoAngle;
  doc["gyro_ok"] = gyroInitialized;
  
  if (gyroInitialized) {
    int resetAngle = normalizeAngle((int)angleZ_reset);
    int absoluteAngle = normalizeAngle((int)angleZ_absolute);
    
    doc["angle_reset"] = resetAngle;      // For F/B straight line
    doc["angle_absolute"] = absoluteAngle;  // Current absolute heading
    doc["is_turning"] = isTurning;
    
    if (isTurning) {
      doc["target_angle"] = targetTurnAngle;
    }
  }
  
  doc["rssi"] = WiFi.RSSI();
  doc["uptime"] = millis() / 1000;
  
  String output;
  serializeJson(doc, output);
  mqttClient.publish(status_topic, output.c_str());
}

// ==================== GYRO FUNCTIONS ====================
void initGyro() {
  if (serialEnabled) Serial.println("Initializing MPU6050...");
  
  if (mpu.begin()) {
    if (serialEnabled) Serial.println("‚úì MPU6050 Found!");
    
    mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
    mpu.setGyroRange(MPU6050_RANGE_500_DEG);
    mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
    
    gyroInitialized = true;
  } else {
    gyroInitialized = false;
    if (serialEnabled) Serial.println("‚ö† MPU6050 not found - continuing without gyro");
  }
}

void calibrateGyro() {
  if (!gyroInitialized) return;
  
  if (serialEnabled) Serial.println("üîÑ Calibrating gyro (50 samples)...");
  
  float sum = 0;
  int validSamples = 0;
  
  for (int i = 0; i < 50; i++) {
    sensors_event_t a, g, temp;
    if (mpu.getEvent(&a, &g, &temp)) {
      sum += g.gyro.z;
      validSamples++;
    }
  }
  
  if (validSamples > 0) {
    gyroZOffset = sum / validSamples;
    
    // Reset both angle tracking systems
    angleZ_reset = 0;
    angleZ_absolute = 0;
    
    if (serialEnabled) {
      Serial.print("‚úì Gyro calibrated! Offset: ");
      Serial.print(gyroZOffset, 4);
      Serial.print(" rad/s (");
      Serial.print(validSamples);
      Serial.println(" samples)");
    }
  } else {
    if (serialEnabled) Serial.println("‚ö† Calibration failed - no valid samples");
  }
}

void updateGyro() {
  if (!gyroInitialized) return;
  
  sensors_event_t a, g, temp;
  if (mpu.getEvent(&a, &g, &temp)) {
    unsigned long currentTime = millis();
    float dt = (currentTime - prevTime) / 1000.0;
    if (dt > 0.1) dt = 0.01;
    if (dt < 0.001) dt = 0.001;
    
    // Apply gyro offset
    float gyroZ = g.gyro.z - gyroZOffset;
    
    // Dead zone filtering
    if (abs(gyroZ) < GYRO_DEAD_ZONE) {
      gyroZ = 0;
      stationaryCount++;
    } else {
      stationaryCount = 0;
    }
    
    // Integrate gyro to get angles (in radians)
    float deltaAngle = gyroZ * dt;
    angleZ_reset += deltaAngle;      // For F/B straight line
    angleZ_absolute += deltaAngle;   // NEVER resets - accumulates forever
    
    // Drift correction for reset angle
    if (stationaryCount > 1000 && millis() - lastDriftCorrection > 5000) {
      if (abs(angleZ_reset) < 0.05) {
        angleZ_reset = 0;
      } else {
        angleZ_reset *= 0.99;
      }
      lastDriftCorrection = millis();
    }
    
    // Convert to degrees and normalize
    // Reset angle wraps for F/B (doesn't accumulate)
    float angleZ_reset_deg = (angleZ_reset / 6.28) * 360.0;
    if (angleZ_reset_deg > 180) angleZ_reset -= 6.28;
    else if (angleZ_reset_deg < -180) angleZ_reset += 6.28;
    
    // Absolute angle can grow indefinitely, but we normalize for display
    // Keep it in radians for internal use
  }
}

// ==================== PID FUNCTIONS ====================
void resetPID() {
  integral = 0;
  previous_error = 0;
}

float computePID(float setpoint, float current_value, float dt) {
  if (dt <= 0 || dt > 0.1) dt = 0.01;
  
  float error = setpoint - current_value;
  
  // Normalize error to -180 to +180 for angle PID
  while (error > 180) error -= 360;
  while (error < -180) error += 360;
  
  integral += error * dt;
  integral = constrain(integral, -50.0, 50.0);
  
  float derivative = (error - previous_error) / dt;
  float output = (Kp * error) + (Ki * integral) + (Kd * derivative);
  output = constrain(output, -100.0, 100.0);
  
  previous_error = error;
  return output;
}

// ==================== MOTOR CONTROL FUNCTIONS ====================
void controlMotors(String direction, int speed, float pidCorrection) {
  int pwmSpeed = map(speed, 0, 100, 0, 255);
  pidCorrection = constrain(pidCorrection, -254, 254);
  int leftSpeed, rightSpeed;
  
  if (direction == "F") {
    leftSpeed = constrain(pwmSpeed + pidCorrection, 0, 255);
    rightSpeed = constrain(pwmSpeed - pidCorrection, 0, 255);
    digitalWrite(IN1_PIN, LOW);
    digitalWrite(IN2_PIN, HIGH);
    digitalWrite(IN3_PIN, HIGH);
    digitalWrite(IN4_PIN, LOW);
    analogWrite(ENA_PIN, leftSpeed);
    analogWrite(ENB_PIN, rightSpeed);
    
  } else if (direction == "B") {
    leftSpeed = constrain(pwmSpeed - pidCorrection, 0, 255);
    rightSpeed = constrain(pwmSpeed + pidCorrection, 0, 255);
    digitalWrite(IN1_PIN, HIGH);
    digitalWrite(IN2_PIN, LOW);
    digitalWrite(IN3_PIN, LOW);
    digitalWrite(IN4_PIN, HIGH);
    analogWrite(ENA_PIN, leftSpeed);
    analogWrite(ENB_PIN, rightSpeed);
    
  } else if (direction == "L") {
    digitalWrite(IN1_PIN, HIGH);
    digitalWrite(IN2_PIN, LOW);
    digitalWrite(IN3_PIN, HIGH);
    digitalWrite(IN4_PIN, LOW);
    analogWrite(ENA_PIN, pwmSpeed);
    analogWrite(ENB_PIN, pwmSpeed);
    
  } else if (direction == "R") {
    digitalWrite(IN1_PIN, LOW);
    digitalWrite(IN2_PIN, HIGH);
    digitalWrite(IN3_PIN, LOW);
    digitalWrite(IN4_PIN, HIGH);
    analogWrite(ENA_PIN, pwmSpeed);
    analogWrite(ENB_PIN, pwmSpeed);
    
  } else {
    stopMotors();
  }
}

void stopMotors() {
  digitalWrite(IN1_PIN, LOW);
  digitalWrite(IN2_PIN, LOW);
  digitalWrite(IN3_PIN, LOW);
  digitalWrite(IN4_PIN, LOW);
  analogWrite(ENA_PIN, 0);
  analogWrite(ENB_PIN, 0);
  isMovingForward = false;
  isMovingBackward = false;
  isTurning = false;
}

void updateServo(int angle) {
  servoAngle = constrain(angle, 0, 180);
  servoMotor.write(servoAngle);
}
// ==================== SETUP ====================
void setup() {
  // ========== STEP 1: SECURE GPIO2 (ENA) IMMEDIATELY ==========
  pinMode(ENA_PIN, OUTPUT);
  digitalWrite(ENA_PIN, LOW);
  
  // ========== STEP 2: SECURE OTHER DIRECTION PINS ==========
  pinMode(IN1_PIN, OUTPUT);
  pinMode(IN2_PIN, OUTPUT);
  pinMode(IN3_PIN, OUTPUT);
  pinMode(IN4_PIN, OUTPUT);
  
  digitalWrite(IN1_PIN, LOW);
  digitalWrite(IN2_PIN, LOW);
  digitalWrite(IN3_PIN, LOW);
  digitalWrite(IN4_PIN, LOW);
  
  delayMicroseconds(100);
  
  // ========== STEP 3: START SERIAL (GPIO1 still used for TX) ==========
  Serial.begin(115200);
  delay(100);
  EEPROM.begin(512);
  
  Serial.println("\n\n========================================");
  Serial.println("  ESP12E CAR BOT CONTROLLER v2.0");
  Serial.println("  Gyro Angle-Based Turning Enabled");
  Serial.println("========================================");
  Serial.println("‚úì ENA (GPIO2) secured with pull-up");
  Serial.println("‚úì Direction pins (IN1-4) initialized");
  Serial.println("‚è≥ ENB (GPIO1/TX) will init after WiFi...");
  
  // ========== STEP 4: INITIALIZE SERVO ==========
  servoMotor.attach(SERVO_PIN);
  servoMotor.write(servoAngle);
  Serial.println("‚úì Servo initialized on GPIO15");
  
  // ========== STEP 5: INITIALIZE GYRO (WITHOUT CALIBRATION YET) ==========
  Wire.begin(4, 5);
  initGyro();
  if (gyroInitialized) {
    Serial.println("‚úì MPU6050 initialized (calibration after WiFi)");
  } else {
    Serial.println("‚ö† MPU6050 not found - PID disabled");
  }
  
  // ========== STEP 6: LOAD CREDENTIALS ==========
  loadCredentials();
  
  // ========== STEP 7: WIFI CONNECTION OR AP MODE ==========
  if (ssid_stored.length() > 0) {
    Serial.println("\n--- Attempting WiFi Connection ---");
    
    while (wifiConnectionAttempts < MAX_WIFI_ATTEMPTS) {
      if (connectToWiFi()) {
        // ========== WIFI CONNECTED! ==========
        Serial.println("\n‚úÖ WiFi connected successfully!");
        
        // ========== GYRO CALIBRATION (AFTER WiFi) ==========
        if (gyroInitialized) {
          Serial.println("\n‚ö†Ô∏è  KEEP ROBOT STILL FOR CALIBRATION!");
          delay(500);
          calibrateGyro();  // ‚Üê CALIBRATE HERE!
        }
        
        // Setup MQTT
        setupMQTT();
        reconnectMQTT();
        
        if (mqttClient.connected()) {
          Serial.println("‚úÖ MQTT connected to broker");
        } else {
          Serial.println("‚ö† MQTT connection failed (will retry in loop)");
        }
        
        // ========== STEP 8: DISABLE SERIAL & INIT ENB ==========
        Serial.println("\nüîÑ Disabling Serial to free GPIO1...");
        Serial.println("‚úÖ GPIO1 (ENB) will control right motor");
        Serial.println("========================================");
        Serial.flush();
        delay(200);
        
        // Disable Serial - frees GPIO1
        disableSerial();
        
        // NOW safe to initialize ENB on GPIO1
        pinMode(ENB_PIN, OUTPUT);
        digitalWrite(ENB_PIN, LOW);
        delay(50);
        
        break;
      }
      
      delay(1000);
    }
    
    // ========== WIFI CONNECTION FAILED ==========
    if (wifiConnectionAttempts >= MAX_WIFI_ATTEMPTS) {
      Serial.println("\n‚ö† All WiFi attempts failed!");
      Serial.println("‚ö† Starting AP mode...");
      startConfigMode();
      setupWebServer();
      Serial.println("‚úÖ AP mode active at http://192.168.4.1");
    }
    
  } else {
    // ========== NO CREDENTIALS - AP MODE ==========
    Serial.println("\n‚ö† No WiFi credentials found");
    Serial.println("‚ö† Starting AP mode...");
    startConfigMode();
    setupWebServer();
    Serial.println("‚úÖ AP mode active");
    Serial.println("   SSID: CarBot_Config");
    Serial.println("   Password: 12345678");
    Serial.println("   URL: http://192.168.4.1");
  }
  
  // ========== STEP 9: INITIALIZE TIMERS ==========
  prevTime = millis();
  lastDriftCorrection = millis();
  lastStatusTime = millis();
  
  // ‚úÖ ONLY print if Serial is still enabled (AP mode)
  if (serialEnabled) {
    Serial.println("\n========================================");
    Serial.println("‚úÖ SYSTEM READY!");
    Serial.println("========================================\n");
  }
}

// ==================== LOOP ====================
void loop() {
  if (configMode) {
    server.handleClient();
    
  } else {
    // ========== MQTT CONNECTION ==========
    if (!mqttClient.connected()) {
      reconnectMQTT();
    }
    mqttClient.loop();
    
    // ========== UPDATE GYRO ==========
    updateGyro();
    
    // ========== ANGLE-BASED TURNING (WITH PID SPEED CONTROL) ==========
    if (isTurning && gyroInitialized) {
      unsigned long currentTime = millis();
      float dt = (currentTime - prevTime) / 1000.0;
      if (dt > 0.1) dt = 0.01;
      if (dt < 0.001) dt = 0.001;
      prevTime = currentTime;
      
      // Get current absolute angle in degrees
      int currentAngle = normalizeAngle((int)((angleZ_absolute / 6.28) * 360.0));
      
      // Calculate error (shortest path)
      int error = getShortestPath(currentAngle, targetTurnAngle);
      
      // Check if reached target (within 2 degrees)
      if (abs(error) < 2) {
        // ‚úÖ TARGET REACHED!
        stopMotors();
      } else {
        // ‚úÖ USE PID TO CALCULATE TURN SPEED!
        float pidOutput = computePID((float)targetTurnAngle, (float)currentAngle, dt);
        
        // Convert PID output to motor speed (0-100%)
        // Scale by 2x and constrain to min 20%, max commanded speed
        int turnSpeed = constrain(abs(pidOutput) * 2, 20, currentSpeed);
        
        // Determine turn direction based on error
        if (error > 0) {
          // Need to turn right (clockwise)
          digitalWrite(IN1_PIN, LOW);
          digitalWrite(IN2_PIN, HIGH);
          digitalWrite(IN3_PIN, LOW);
          digitalWrite(IN4_PIN, HIGH);
          
          int pwmSpeed = map(turnSpeed, 0, 100, 0, 255);
          analogWrite(ENA_PIN, pwmSpeed);
          analogWrite(ENB_PIN, pwmSpeed);
          
        } else {
          // Need to turn left (counter-clockwise)
          digitalWrite(IN1_PIN, HIGH);
          digitalWrite(IN2_PIN, LOW);
          digitalWrite(IN3_PIN, HIGH);
          digitalWrite(IN4_PIN, LOW);
          
          int pwmSpeed = map(turnSpeed, 0, 100, 0, 255);
          analogWrite(ENA_PIN, pwmSpeed);
          analogWrite(ENB_PIN, pwmSpeed);
        }
      }
    }
    
    // ========== STRAIGHT LINE MOVEMENT (F/B with PID) ==========
    else if (isMovingForward || isMovingBackward) {
      unsigned long currentTime = millis();
      float dt = (currentTime - prevTime) / 1000.0;
      if (dt > 0.1) dt = 0.01;
      if (dt < 0.001) dt = 0.001;
      prevTime = currentTime;
      
      if (gyroInitialized) {
        // Use reset angle for straight line PID
        int resetAngle = normalizeAngle((int)((angleZ_reset / 6.28) * 360.0));
        float pidOutput = computePID(desired_angle_reset, (float)resetAngle, dt);
        controlMotors(currentDirection, currentSpeed, pidOutput);
      } else {
        // No gyro - drive straight without PID
        controlMotors(currentDirection, currentSpeed, 0);
      }
    }
    
    // ========== PUBLISH STATUS ==========
    if (millis() - lastStatusTime > 2000) {
      publishStatus();
      lastStatusTime = millis();
    }
  }
  
  delay(10);
}
